'use strict';

const V = M;
(function (e, f) {
  const b = M;
  const c = e();
  while (true) {
    try {
      const d = -parseInt(b(394)) / 1 * (parseInt(b("0x245")) / 2) + -parseInt(b(372)) / 3 + parseInt(b("0x246")) / 4 + -parseInt(b("0x217")) / 5 * (-parseInt(b(580)) / 6) + -parseInt(b(354)) / 7 * (parseInt(b("0x167")) / 8) + -parseInt(b("0x248")) / 9 + -parseInt(b("0x223")) / 10 * (-parseInt(b("0x1d4")) / 11);
      if (d === f) {
        break;
      } else {
        c.push(c.shift());
      }
    } catch (b) {
      c.push(c.shift());
    }
  }
})(K, 177117);
const a = {
  [V(519)]: true
};
Object[V(481) + V(380)](exports, V(479), a);
exports[V("0x21e") + V("0x1c6")] = undefined;
const W = require("ue");
const X = require("../../Utils/ModUtils");
const c = require("puerts");
const Y = require("../../ModManager");
const e = require("../ModMethod");
const d = require("../KillAura");
const f = require("../../Component/TreasureTp");
const g = require("../../../ModMenu");
const b = require("../../Utils/Logger");
const h = require("../MobVacuum");
const i = V("0x1b4") + "on";
const j = require("./KeyDefine");
const k = require("../CustomTp");
const l = require("../../Utils/UI");
const m = require("../buffMethod");
const n = require("../EntityManager");
const o = V(381) + "_com_count_number";
const p = require("../../Utils/ConfigManager");
const q = require("../Flight");
const r = require("../../Utils/InputKeyController");
const s = j[V("0x150") + V(373) + "T"];
const t = {
  [V("0x1a8")]: "X",
  [V("0x229")]: "Toggle"
};
const u = {
  [V("0x1a8")]: null
};
u.type = V(365);
const v = {
  key: null
};
v.type = V("0x183");
const w = {};
w[V(424)] = V("0x1b3");
w[V(553)] = V(387);
const x = {
  key: null,
  [V("0x229")]: "Toggle"
};
const y = {
  [V(424)]: null
};
y.type = V(387);
const z = {
  key: null,
  [V(553)]: "Toggle"
};
const A = {
  [V(424)]: "Right",
  [V(553)]: "Press"
};
const B = {
  [V("0x1a8")]: null
};
B[V("0x229")] = V("0x183");
const C = {
  [V("0x1a8")]: "Left"
};
C[V(553)] = V(534);
const D = {
  key: "T"
};
D[V("0x229")] = V(534);
const E = {
  [V("0x1a8")]: "V",
  [V(553)]: "Press"
};
const F = {};
F[V("0x1a8")] = V("0x1d5");
F[V(553)] = V(534);
const G = {};
G[V(424)] = V("0x1cd");
G.type = V(387);
const H = {};
H[V(424)] = V("0x177");
H[V(553)] = V("0x183");
const I = {
  [V(424)]: "F9",
  type: "Toggle"
};
const J = {};
function K() {
  const b = ["Config", "ModManager", "ffOption", "Toggle", "e Time", "ApplyBuff", "logger", " to clipbo", "Dir", "ard!", "1EMvoKF", "ACTION_TYP", "forEach", "Action", "MobVacuumT", "GoToNextPo", "nChanged", "NoClip", "Trigger Ac", "isWidgetLo", "Time", "toString", "Init keybi", "PlayerSpee", "retrying..", "SelectBuff", "Auto Resta", "ger", "ShowModMen", "Failed ini", "QuestX", "PrevTp", "settings", "CLEAR_NAME", "aded", "isKeyDown", "buffType", "QuestY", "killAura", "tateText", "key", "Freeze Gam", "Key", "ties", "asureTelep", "rKey", "Keybind no", "Always Sho", "d or empty", "Player Spe", "AlwaysShow", "Five", "Keybind.js", "indChanges", "onTypeChan", "[ Keybind:", "gistered!", "LoadConfig", "ListenClea", "MarkX", "InputKeyCo", "Cursor", "ortText", "\" not foun", "CopyTpCord", "Echo Vacuu", "ModMenu", "Menu", "AutoRestar", "Applied Bu", "troller", "LGUIBPLibr", "dTime", "listenActi", "updateDefa", "bindKeyToU", "bShift", "F11", "function", "inate", "Add", "keysState", "tate", "OnSelectio", "7011037kWNJZp", "F12", "ModUtils", "CordinateS", " empty con", "EntityMana", "TeleportTo", "ind", "UpdateKeyb", "hold", "CheckConfi", "__esModule", "trim", "defineProp", "IsTping", "leport", "ding", "updateStat", "dOption", "ClipBoardC", "OnKeySelec", "buffManage", "NAME", "name", "dInterval", "mpty objec", "AddOption", "ted", "Coordinate", "howCursor", "fault keyb", "keybindLoa", "oaded", "Flight", "TreasureWi", "be a non-e", "selectedBu", "htMode", "Overlay", "ClearOptio", "World Spee", "teleport", "\" does not", "NextTp", "MobVacuum", "UpdateKeyS", "ShowTip", "Mod", "PlayAudio", "SetWorldSp", "MarkTp", "value", "ff ", "ntroller", "updateType", "rld", "KEY_NAME", "nd...", "killEntity", "OnClicked", "ConfigMana", "keybinds", "gExists", " exist in ", "indTrigger", "IsKeyHold", "Press", "871825ISHPrO", "imer", "Hold", "UnstuckLoa", "dget", "ToFile", "GetSelecte", "KeybindCon", "peed", "IsInGame", "bCmd", "Action nam", "10GjsABb", "ary", "Log", "RunKillAur", "IsInBoat", "Timer", "type", "eed", "TreasureTe", "ctivate", "isHolding", "Invalid or", "triggerKey", "ShowStatus", "kill Aura", "Buff loade", "keybinds.", "tDungeon", "Library", "e \"", "Capitalize", "holdInterv", "SaveConfig", "inds.", "KuroStatic", "KeyName", "IsInMapVie", "MainMenu", "EchoVacuum", "opy", "values", "t found", "FreezeGame", "6DzqgJl", "245738rnUjng", "80220ZMAocI", "toggleFlig", "190908geUtMu", "keys", "Keybind fo", "KillAura", "ReloadBuff", "ACTION_ATT", "rt Dungeon", "keyMenu", "WorldSpeed", "usPos", "QuestZ", "TYPE_LIST", "ges", "error", "GoTp", "find", "sMod", "SaveString", " file:", "CustomTp", "toLowerCas", "ModMethod", "Config fil", "416227DVWCmu", "TreasureTp", "eMod", ", using de", "SetSelecte", "40wFFaAB", "e not foun", "buffMethod", "Mob Vacuum", "lyBuff", "MarkTpPosZ", "press", "bAlt", "MarkY", "None", "IsInGameWo", "dKey", "Treasure", "639852HBpPSt", "RIBUTE_LIS", "bCtrl", "F10", "isKeybindL", " was saved", "ultSetting", "addKey", "erty", "play_ui_fx", "QuestTp", "SetPlayerS"];
  K = function () {
    return b;
  };
  return K();
}
J[V("0x1a8")] = null;
J[V("0x229")] = "Toggle";
const L = {};
function M(d, a) {
  const e = K();
  M = function (c, f) {
    c = c - 335;
    let b = e[c];
    return b;
  };
  return M(d, a);
}
L.key = null;
L[V("0x229")] = "Press";
const N = {
  [V("0x1a8")]: null,
  [V("0x229")]: "Press"
};
const O = {
  [V("0x1a8")]: null
};
O[V("0x229")] = V("0x216");
const P = {
  [V("0x1c2")]: t,
  TreasureTeleport: u,
  KillAura: v,
  Flight: w,
  MobVacuum: x,
  [V(339)]: y,
  PlayerSpeed: z,
  NextTp: A,
  [V("0x191")]: B,
  [V(415)]: C,
  MarkTp: D,
  QuestTp: E,
  ["ReloadBuff" + V(384)]: F,
  [V("0x1b2") + V(445)]: G,
  [V(579) + V("0x194")]: H,
  [V("0x23f")]: I,
  [V("0x1c4") + V(564)]: J,
  [V(448) + V("0x1cf")]: L,
  [V("0x21a") + "ding"]: N,
  [V(389)]: O
};
class Q {
  constructor() {
    // TOLOOK
    // TOLOOK
    setTimeout(() => {
      this.InitKeyBind();
    }, 1000);
  }
  InitKeyBind() {
    const f = V;
    try {
      X[f(470)][f(549)](f("0x196") + f("0x20d"));
      if (Q[f("0x178") + f(500)]) {
        const b = Object.values(Q[f(529)]);
        const g = Object[f("0x249")](Q[f("0x211")]);
        b[f(396)]((b, a) => {
          const c = f;
          if (b[c(424)]) {
            r["InputKeyCo" + c(521)][c(379)](g[a], b[c("0x1a8")]);
          }
        });
        X[f(470)].Log("Keybind re" + f(440));
      } else {
        // TOLOOK
        // TOLOOK
        setTimeout(() => {
          const b = f;
          this.InitKeyBind();
          X.ModUtils[b("0x225")](b("0x19d") + "t keybind " + b(408) + ".", b("0x158"));
        }, 2500);
      }
    } catch (b) {
      X[f("0x1d6")].Log(b, f("0x158"));
    }
  }
  static ["loadKeybin" + V("0x1c8")] = null;
  static keyMenu = null;
  static [V(465)] = {};
  static [V(568) + "al"] = null;
  static [V("0x211")] = P;
  static [V("0x178") + "oaded"] = false;
  static [V(499) + V("0x1ec")] = null;
  static [V(526) + V(552)] = null;
  static [V(398) + V(536)] = null;
  static ["UpdateKeyb" + V("0x1db")](d, b, a) {
    const e = V;
    if (!d) {
      return;
    }
    const c = this[e("0x211")][d];
    if (!c) {
      X[e(470)].Log(e("0x222") + e(566) + d + (e(510) + e("0x213") + e("0x233")), e(344));
      return;
    }
    this[e("0x1ca") + e(378) + e("0x15b")](d, c[e(553)]);
    if (!b || b === "") {
      c[e(424)] = null;
      Q[e("0x166") + e("0x172")](a, null);
      return;
    }
    const f = Object.entries(Q[e("0x211")])[e("0x15a")](([, c]) => c[e(424)] === b);
    if (f) {
      const [g, a] = f;
      if (g !== d) {
        const c = Object[e("0x241")](s);
        const b = c[e("0x15a")](a => a.NAME === g);
        a[e(424)] = null;
        Q[e(358) + e(370)](b[e("0x20c")], null);
      }
    }
    c[e("0x1a8")] = b;
    r.InputKeyController[e(379)](d, b);
  }
  static [V(458) + V("0x17a") + V("0x15b")](a, b) {
    const c = V;
    if (b === c(537)) {
      if (a === c("0x153")) {
        e.ModMethod[c("0x205") + c(554)](false);
      } else if (a === "PlayerSpeed") {
        e[c(352)]["SetPlayerS" + c("0x21f")](false);
      }
    }
  }
  static [V("0x20a") + V("0x18d")](a, b) {
    const c = V;
    const d = Q.keybinds[a];
    this[c(458) + "ultSettingsMod"](a, b);
    if (!d) {
      X[c("0x1d6")][c(549)](c(430) + c("0x242"), c("0x158"));
      return;
    } else if (!b) {
      return;
    }
    d[c("0x229")] = b;
  }
  static [V(559)]({
    actionName: d = null,
    func: b = null,
    onToggle: j = null,
    onHold: e = null,
    onPress: f = null
  }) {
    const g = V;
    try {
      const h = Q[g("0x211")][d];
      if (!h) {
        X[g("0x1d6")][g("0x225")](g(586) + "r action \"" + d + (g(447) + "d."), g("0x158"));
        return;
      }
      if (!h[g(424)]) {
        return;
      }
      let a = false;
      switch (h[g(553)][g("0x15f") + "e"]()) {
        case "press":
          a = r[g(444) + g("0x209")][g("0x1a3")](h[g(424)]);
          if (a && typeof f === g(462) && f) {
            f();
          }
          break;
        case g(477):
          const b = Q[g("0x1d1")]?.[d] || false;
          a = r["InputKeyCo" + g("0x209")][g("0x215")](h.key, 100);
          if (typeof e === g(462) && e) {
            if (a && !b) {
              this[g("0x238") + "al"] = // TOLOOK
              // TOLOOK
              setInterval(() => {
                const b = {
                  isHolding: true
                };
                e(b);
              }, 100);
            } else if (!a && b) {
              const b = {
                [g(557)]: false
              };
              e(b);
              clearInterval(this[g(568) + "al"]);
              this[g("0x238") + "al"] = null;
            }
          }
          Q[g("0x1d1")] = {
            ...Q.keysState,
            [d]: a
          };
          break;
        case "toggle":
          a = r["InputKeyCo" + g(521)].IsMyKeyUp(h[g(424)]);
          if (a && typeof j === "function" && j) {
            j();
          }
          break;
      }
      if (b && typeof b === "function") {
        b();
      }
    } catch (b) {
      X[g(470)][g(549)](g(402) + "tion Error " + b, g(344));
    }
  }
  static [V(485) + V(356)](a) {
    const b = V;
    const c = Y[b("0x181")][b(416)][a];
    Y[b(385)][b(416)][a] = !c;
  }
  static ["ListenKeyb" + V("0x214")]() {
    const p = V;
    try {
      this[p(559)]({
        actionName: s[p(450)].NAME,
        onToggle: () => {
          const b = p;
          g[b(574)][b("0x19c") + "u"]();
        }
      });
      this[p("0x22f")]({
        actionName: s[p(555) + "leport"][p("0x1ea")],
        onPress: () => {
          const b = p;
          if (!X[b("0x1d6")][b(369) + b(523)]() || !Y[b("0x181")].settings[b("0x163") + b("0x1fa")]) {
            return;
          }
          X[b(470)][b("0x204")](o);
          f[b(355)][b("0x1da") + b("0x173")]();
        }
      });
      this[p(559)]({
        actionName: s[p(335) + "Config"][p(490)],
        onPress: () => {
          const c = p;
          try {
            m.buffMethod[c("0x1b9")]();
            g[c(574)].Menu[c("0x199")].ClearOptions();
            m[c("0x169")].buffType[c(396)](a => g[c("0x23e")][c("0x1c3")][c("0x199")].AddOption(a[c(491)]));
            g[c("0x23e")].Menu[c(409)]["SetSelecte" + c("0x1e6")](m[c("0x169")][c("0x1a4")][Y[c("0x181")][c(416)][c(420)]].name);
            l.UI.ShowTip(c(562) + "d!");
          } catch (b) {}
        }
      });
      this[p(559)]({
        actionName: s[p("0x1b2") + "Cursor"].NAME,
        onToggle: () => {
          const b = p;
          try {
            X.ModUtils[b(516)](o);
            Y.ModManager[b(416)][b(434) + b(445)] = !Y[b(385)][b("0x1a0")][b(434) + b(445)];
            l.UI[b("0x230") + b("0x203")](b("0x1b2") + b("0x1bd"), b(431) + "w Cursor");
            e[b(352)]["SetAlwaysS" + b("0x1f1")](Y[b(385)].settings.AlwaysShowCursor);
          } catch (b) {}
        }
      });
      if (!X[p(470)][p("0x220")]() || g[p(574)][p("0x1c3")].IsVisible()) {
        return;
      }
      this.triggerKey({
        actionName: s[p(587)].NAME,
        onToggle: () => {
          const b = p;
          X.ModUtils.PlayAudio(o);
          Y[b("0x181")][b("0x1a0")][b("0x1a6")] = !Y[b("0x181")][b(416)][b(422)];
          l.UI[b("0x230") + "Mod"]("killAura", b("0x231"));
        },
        onPress: () => {
          const c = p;
          if (Q[c(526) + c("0x228")]) {
            return;
          }
          Q[c(526) + c(552)] = // TOLOOK
          // TOLOOK
          setTimeout(() => {
            const a = c;
            d[a("0x24b")][a("0x226") + "a"]();
            Q[a("0x20e") + "Timer"] = null;
          }, 100);
        },
        onHold: ({
          isHolding: b
        }) => {
          const e = p;
          if (b) {
            if (Q.killEntityTimer) {
              return;
            }
            Q[e("0x20e") + e("0x228")] = // TOLOOK
            // TOLOOK
            setTimeout(() => {
              const b = e;
              d[b("0x24b")][b("0x226") + "a"]();
              Q["killEntity" + b("0x228")] = null;
            }, 300);
          }
        }
      });
      this[p(559)]({
        actionName: s.Flight.NAME,
        onToggle: () => {
          const b = p;
          if (Y[b(385)][b(416)].flightMode) {
            q[b("0x1f5")][b("0x247") + b("0x1f9")]();
          }
        }
      });
      this[p(559)]({
        actionName: s[p("0x191")][p(490)],
        onToggle: () => {
          const b = p;
          X.ModUtils[b("0x204")](o);
          const a = Y.ModManager[b("0x1a0")].NoClip;
          e[b(352)][b(401)](!a);
          Y[b(385)][b("0x1a0")][b("0x191")] = !a;
          return l.UI.ShowStatusMod(b("0x191"), "No Clip");
        }
      });
      this[p(559)]({
        actionName: s.PlayerSpeed[p("0x1ea")],
        onToggle: () => {
          const b = p;
          X.ModUtils.PlayAudio(o);
          const a = Y[b("0x181")][b(416)][b(407) + "d"];
          e.ModMethod[b("0x17f") + b("0x21f")](!a);
          Y.ModManager[b(416)][b(407) + "d"] = !a;
          return l.UI["ShowStatus" + b("0x203")](b("0x197") + "d", b(433) + "ed");
        },
        onHold: ({
          isHolding: b
        }) => {
          const a = p;
          if (b && Y.ModManager[a(416)][a(407) + "d"]) {
            e[a("0x160")]["SetPlayerS" + a(543)](true);
          } else {
            e.ModMethod[a(383) + a("0x21f")](false);
          }
        }
      });
      this.triggerKey({
        actionName: s.WorldSpeed[p(490)],
        onToggle: () => {
          const b = p;
          X[b(470)][b("0x204")](o);
          const a = Y[b("0x181")][b("0x1a0")][b("0x153")];
          e[b(352)][b(517) + b("0x22a")](!a);
          Y[b("0x181")][b(416)][b(339)] = !a;
          return l.UI[b("0x230") + b("0x203")](b(339), b("0x1fc") + "d");
        },
        onHold: ({
          isHolding: b
        }) => {
          const a = p;
          if (b && Y.ModManager[a(416)][a(339)]) {
            e[a("0x160")][a(517) + a("0x22a")](true);
          } else {
            e.ModMethod[a("0x205") + a(554)](false);
          }
        }
      });
      this.triggerKey({
        actionName: j[p("0x150") + p(373) + "T"][p("0x1ff")].NAME,
        onPress: () => {
          const b = p;
          X[b(470)][b(516)](o);
          k.CustomTp[b("0x18f") + "s"]();
          k[b(350)][b("0x159")]();
        }
      });
      this[p("0x22f")]({
        actionName: j[p(336) + p(373) + "T"][p(415)].NAME,
        onPress: () => {
          const b = p;
          X[b(470)][b("0x204")](o);
          k[b("0x15e")]["GoToPrevio" + b("0x154")]();
          k[b("0x15e")].GoTp();
        }
      });
      this.triggerKey({
        actionName: j["ACTION_ATT" + p(373) + "T"][p("0x206")][p("0x1ea")],
        onPress: () => {
          const b = p;
          if (!Y[b("0x181")][b(416)][b(518)] || !X.ModUtils[b(573) + "w"]()) {
            return;
          }
          X[b(470)][b("0x204")](o);
          let a = Y[b(385)].settings.MarkZ;
          if (a == 0) {
            a = Y[b(385)].settings[b(364)];
          }
          const d = {};
          d.x = Y.ModManager.settings[b("0x1bb")] * 100;
          d.y = Y[b(385)][b(416)][b("0x16f")] * 100;
          d.z = a * 100;
          k[b(350)][b(509)](d);
        }
      });
      this[p("0x22f")]({
        actionName: j[p(336) + p("0x175") + "T"][p("0x17e")].NAME,
        onPress: () => {
          const c = p;
          if (!Y[c("0x181")][c("0x1a0")][c("0x17e")] || X[c(470)][c("0x1e2")]() || X[c(470)][c("0x227")]() || !X[c("0x1d6")][c("0x171") + c("0x20b")]()) {
            return;
          }
          X[c(470)][c("0x204")](o);
          if (Y[c(385)][c("0x1a0")][c(414)] != 0 && Y[c("0x181")].settings[c("0x1a5")] != 0 && Y[c("0x181")][c("0x1a0")][c(341)] != 0) {
            const a = {};
            a.x = Y[c(385)][c(416)][c(414)];
            a.y = Y[c("0x181")][c("0x1a0")].QuestY;
            a.z = Y[c(385)][c("0x1a0")].QuestZ;
            k[c("0x15e")][c("0x1fd")](a);
          }
        }
      });
      this.triggerKey({
        actionName: j[p(336) + p("0x175") + "T"].MobVacuum[p("0x1ea")],
        onHold: ({
          isHolding: b
        }) => {
          const d = p;
          if (b && Y[d(385)][d("0x1a0")].MobVacuum) {
            if (this[d("0x18e") + d(536)]) {
              return;
            }
            this["MobVacuumT" + d("0x218")] = // TOLOOK
            // TOLOOK
            setTimeout(() => {
              const e = d;
              h;
              n[e(473) + e("0x19b")]["GetAllEnti" + e(427)]().forEach(a => {
                const b = e;
                h[b("0x200")][b(512)](a);
              });
              this[e("0x18e") + e("0x218")] = null;
            }, 200);
          }
        },
        onToggle: () => {
          const b = p;
          X[b("0x1d6")][b("0x204")](o);
          const a = Y[b(385)][b("0x1a0")][b(512)];
          Y[b(385)][b(416)][b("0x200")] = !a;
          l.UI[b(560) + "Mod"]("MobVacuum", b("0x16a"));
        }
      });
      this[p("0x22f")]({
        actionName: j["ACTION_ATT" + p(373) + "T"].EchoVacuum[p(490)],
        onToggle: () => {
          const b = p;
          X[b(470)][b(516)](o);
          const a = Y[b("0x181")][b("0x1a0")][b("0x23f")];
          Y[b(385)][b(416)][b("0x23f")] = !a;
          l.UI[b(560) + b("0x203")](b(575), b("0x1c1") + "m");
        }
      });
      this[p("0x22f")]({
        actionName: s[p("0x243") + "Time"][p("0x1ea")],
        onToggle: () => {
          const b = p;
          try {
            X[b(470)].PlayAudio(o);
            Y[b(385)].settings[b("0x243") + b("0x194")] = !Y[b(385)][b("0x1a0")]["FreezeGame" + b("0x194")];
            l.UI.ShowStatusMod(b(579) + b(404), b(425) + b(388));
            e[b("0x160")]["FreezeGame" + b("0x194")](Y.ModManager[b(416)][b(579) + "Time"]);
          } catch (b) {}
        }
      });
      this[p("0x22f")]({
        actionName: s.AutoRestartDungeon.NAME,
        onToggle: () => {
          const b = p;
          X[b(470)][b("0x204")](o);
          const a = Y.ModManager.settings[b("0x1c4") + b("0x234")];
          Y[b("0x181")].settings[b("0x1c4") + b("0x234")] = !a;
          l.UI[b("0x230") + "Mod"](b("0x1c4") + b(564), b(410) + b(337));
        }
      });
      this[p(559)]({
        actionName: s[p("0x1c0") + p(463)][p(490)],
        onPress: () => {
          const b = p;
          X.ModUtils[b(516)](o);
          const {
            x: a,
            y: c,
            z: d
          } = Y[b("0x181")][b(416)][b(471) + b("0x1d2")];
          const e = {
            x: a,
            y: c,
            z: d
          };
          W[b(455) + b(548)][b("0x1e7") + b(576)](JSON.stringify(e));
          l.UI[b("0x202")](b("0x1f0") + b(377) + b(391) + b(393));
        }
      });
      this[p(559)]({
        actionName: s[p("0x21a") + p(484)][p("0x1ea")],
        onPress: () => {
          const b = p;
          X[b(470)][b("0x204")](o);
          e[b(352)][b(538) + "ding"]();
        }
      });
      this[p(559)]({
        actionName: s[p("0x185")][p("0x1ea")],
        onPress: () => {
          const b = p;
          const a = m.buffMethod[b("0x1e9") + "r"][b("0x1f8") + b(386)];
          m[b(361)]["RequestApp" + b(363)](a);
          X.ModUtils[b(516)](o);
          if (a) {
            l.UI.ShowTip(b("0x1c5") + b(520) + a[b(491)]);
          }
        }
      });
    } catch (b) {
      X[p("0x1d6")].Log(b, p("0x158"));
    }
  }
  static [V(541) + V("0x172")](a) {
    const b = V;
    return a[b("0x1aa")][b("0x23c")][b(405)]();
  }
  static [V(513) + V(423)]() {
    const c = V;
    try {
      if (f.TreasureTp[c(403) + c("0x1a2")]) {
        f[c("0x163")][c("0x1f6") + c(539)]["KeybindTre" + c(428) + c(446)].SetText(c(439) + " " + (this[c("0x211")][c(555) + c("0x1e3")][c(424)] ? this[c(529)][c("0x22b") + "leport"][c("0x1a8")] : c(368)) + " ]");
      }
    } catch (b) {
      X[c("0x1d6")].Log(b, c(344));
    }
  }
  static ["listenKeyb" + V(437)]() {
    const e = V;
    try {
      if (!this[e("0x178") + e("0x1f4")]) {
        return;
      }
      clearInterval(Q["keybindLoa" + e(492)]);
      Q[e(499) + e("0x1ec")] = null;
      const b = Q[e("0x152")];
      if (!b) {
        X.ModUtils[e("0x225")]("Menu is undefined", e(344));
        return;
      }
      const a = Object[e(577)](s);
      a[e("0x18c")](f => {
        const c = e;
        if (f.KEY_NAME) {
          b[f[c("0x20c")]][c(488) + c("0x1ef")][c("0x1d0")](d => {
            const a = c;
            const b = this[a("0x21d") + "dKey"](d);
            this[a("0x1dc") + a("0x1db")](f[a("0x1ea")], b, f.KEY_NAME);
          });
        }
      });
      this[e(442) + e(429)]();
      this[e("0x1c9") + e("0x1b6") + e("0x157")]();
      this[e(459) + "I"]();
    } catch (b) {
      X.ModUtils.Log(b, e(344));
    }
  }
  static ["isAllowToA" + V(556)](a) {
    const b = V;
    try {
      return Q[b(529)][a][b("0x229")][b("0x15f") + "e"]() === "toggle" || !Q.keybinds[a][b("0x1a8")];
    } catch (c) {
      X.ModUtils.Log(c, b("0x158"));
      return false;
    }
  }
  static [V(459) + "I"]() {
    const f = V;
    try {
      const b = Object[f(577)](s);
      b[f("0x18c")]((b, a) => {
        const c = f;
        if (b.ACTION_TYPE) {
          Q[c("0x152")][b[c(395) + "E"]][c("0x1fb") + "ns"]();
        }
      });
      b[f("0x18c")]((d, a) => {
        const g = f;
        if (d[g(395) + "E"]) {
          d.TYPE_LIST[g("0x18c")](a => {
            const b = g;
            Q.keyMenu[d[b("0x18b") + "E"]][b("0x1ee")](X[b(470)].Capitalize(a));
          });
        }
      });
      b[f(396)]((d, a) => {
        const c = f;
        if (Q[c(529)][d[c(490)]][c(424)] && d[c("0x20c")]) {
          Q[c(358) + c(370)](d.KEY_NAME, Q.keybinds[d.NAME][c("0x1a8")]);
        }
        if (d.ACTION_TYPE) {
          const a = d[c(342)][c(346)](a => a === Q[c("0x211")][d[c(490)]][c(553)]);
          if (a) {
            Q[c("0x152")][d[c(395) + "E"]]["SetSelecte" + c("0x1e6")](X.ModUtils[c(567)](a));
          } else {
            Q[c("0x152")][d[c(395) + "E"]][c(358) + c(486)](X[c(470)][c("0x237")](d[c("0x156")][0]));
          }
        }
      });
    } catch (b) {
      X.ModUtils[f(549)](b, "error");
    }
  }
  static ["listenActi" + V("0x1b6") + V("0x157")]() {
    const e = V;
    try {
      const b = Object[e("0x241")](j[e(336) + "RIBUTE_LIST"]);
      b[e("0x18c")]((f, a) => {
        const g = e;
        if (f[g(395) + "E"]) {
          Q[g("0x152")][f[g("0x18b") + "E"]][g(467) + g(400)][g(464)](() => {
            const a = g;
            const b = Q[a("0x152")][f[a(395) + "E"]]["GetSelecte" + a("0x1e6")]();
            if (!b) {
              return;
            }
            this[a(522) + a("0x18d")](f[a("0x1ea")], b);
          });
        }
      });
    } catch (b) {
      X.ModUtils[e(549)](b, e(344));
    }
  }
  static ["SetSelecte" + V(370)](f, b) {
    const c = V;
    try {
      const e = {
        KeyName: b
      };
      const a = {
        [c(426)]: e,
        [c("0x16e")]: false,
        [c(545)]: false,
        [c(374)]: false,
        [c(460)]: false
      };
      Q[c("0x152")][f][c("0x166") + c("0x172")](a);
    } catch (b) {
      X.ModUtils[c(549)](b, c(344));
    }
  }
  static ["ListenClea" + V("0x1ad")]() {
    const d = V;
    const a = Object[d("0x241")](j[d("0x150") + d("0x175") + "T"]);
    a[d(396)](e => {
      const a = d;
      if (e.CLEAR_NAME) {
        Q[a(338)][e[a("0x1a1")]][a(527)].Add(() => {
          const c = a;
          Q[c(358) + c(370)](e[c(524)], null);
        });
      }
    });
  }
  static [V("0x1de") + V(530)]() {
    const a = V;
    const b = p[a(528) + a("0x19b")][a(478) + "gExists"](i);
    return b;
  }
  static SaveConfig() {
    const a = V;
    Q[a(376) + a("0x1f4")] = true;
    W[a(571) + a(565)][a(348) + a(540)](JSON.stringify(this[a("0x211")], null, 2), p[a(528) + a("0x19b")][a("0x1b9") + a("0x188")]() + i);
  }
  static [V("0x1b9")]() {
    const d = V;
    Q.isKeybindLoaded = false;
    let b = p.ConfigManager.GetConfig(i);
    if (!b || b[d(480)]() === "") {
      c[d("0x186")].warn(d(353) + d(360) + d(432) + d("0x165") + d(498) + d(570));
      this[d(529)] = Q[d(529)];
      Q[d("0x239")]();
      return;
    }
    try {
      b = JSON.parse(b);
      if (typeof b !== "object" || b === null || Object[d("0x249")](b).length === 0) {
        throw new Error(d("0x22e") + d("0x1d8") + "fig: must " + d("0x1f7") + d("0x1ed") + "t.");
      }
      const c = {
        ...Q[d(529)],
        ...b
      };
      this.keybinds = c;
    } catch (b) {
      c[d("0x186")][d("0x158")]("Error parsing config" + d("0x15d"), b);
      this[d("0x211")] = Q[d("0x211")];
    }
    Q[d(569)]();
  }
}
exports[V("0x21e") + V(454)] = Q;